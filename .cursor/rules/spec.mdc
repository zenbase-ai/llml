---
description:
globs:
alwaysApply: true
---
# LLML Technical Specification

Version: 0.2.0, June 29th 2025

## Overview

LLML (Lightweight Language Markup Language) is a data serialization format that transforms nested data structures into human-readable, XML-like markup. This specification defines the exact transformation rules that must be implemented consistently across all language implementations.

## Core Transformation Rules

### 1. Empty Value Handling

Empty values are transformed to empty strings:

```
llml() → ""
llml([]) → ""
llml({}) → ""
```

Special case for empty named arrays:
```
llml({items: []}) → ""  # Empty arrays within objects are omitted entirely
llml([[], [[]]]) → ""  # Empty arrays within arrays are omitted entirely
```

### 2. Primitive Value Formatting

All primitive values are wrapped in XML-like tags using the key name:

**Strings:**
```
llml({message: "Hello"}) → "<message>Hello</message>"
llml({empty: ""}) → "<empty></empty>"
```

**Numbers:**
```
llml({count: 42}) → "<count>42</count>"
llml({temperature: 98.6}) → "<temperature>98.6</temperature>"
llml({zero: 0}) → "<zero>0</zero>"
```

**Booleans:**
```
llml({enabled: true}) → "<enabled>true</enabled>"  # TypeScript
llml({enabled: True}) → "<enabled>True</enabled>"  # Python
llml({disabled: false}) → "<disabled>false</disabled>"  # TypeScript
llml({disabled: False}) → "<disabled>False</disabled>"  # Python
```

**Null/None/Undefined:**
```
llml({value: null}) → "<value>null</value>"  # TypeScript
llml({value: None}) → "<value>None</value>"  # Python
llml({value: undefined}) → "<value>undefined</value>"  # TypeScript
```

### 3. Key Normalization (Kebab-Case Conversion)

All keys are automatically converted to kebab-case:

**Snake Case:**
```
user_name → user-name
debug_mode → debug-mode
```

**CamelCase:**
```
userName → user-name
maxRetries → max-retries
userAge → user-age
```

**Spaces:**
```
"key with spaces" → key-with-spaces
```

### 4. Multiple Key-Value Pairs

Multiple key-value pairs are separated by newlines:

```
llml({name: "Alice", age: 30, active: true})
→
<name>Alice</name>
<age>30</age>
<active>true</active>
```

### 5. Array/List Formatting

Arrays are formatted with special wrapper tags and numbered items:

**Basic Arrays:**
```
llml({rules: ["first", "second", "third"]})
→
<rules>
  <rules-1>first</rules-1>
  <rules-2>second</rules-2>
  <rules-3>third</rules-3>
</rules>
```

**Numeric Arrays:**
```
llml({numbers: [1, 2, 3]})
→
<numbers>
  <numbers-1>1</numbers-1>
  <numbers-2>2</numbers-2>
  <numbers-3>3</numbers-3>
</numbers>
```

**Kebab-Case Array Names:**
```
llml({user_tasks: ["task1", "task2"]})
→
<user-tasks>
  <user-tasks-1>task1</user-tasks-1>
  <user-tasks-2>task2</user-tasks-2>
</user-tasks>
```

### 6. Direct Array Formatting

When an array is passed directly (not as a property), it uses numeric tags:

```
llml(["a", "b", "c"])
→
<1>a</1>
<2>b</2>
<3>c</3>
```

**Mixed Types:**
```
llml([1, "hello", true])
→
<1>1</1>
<2>hello</2>
<3>true</3>
```

**Objects in Direct Arrays:**
```
llml([{name: "Alice"}, {name: "Bob"}])
→
<1>
  <1-name>Alice</1-name>
</1>
<2>
  <2-name>Bob</2-name>
</2>
```

### 7. Nested Object Formatting

Nested objects are formatted recursively with proper indentation. By default (`strict: false`), nested object properties do not include parent key prefixes:

**Simple Nesting (Default):**
```
llml({config: {debug: true, timeout: 30}})
→
<config>
  <debug>true</debug>
  <timeout>30</timeout>
</config>
```

**With Kebab-Case Conversion (Default):**
```
llml({user_config: {debug_mode: true, maxRetries: 5}})
→
<user-config>
  <debug-mode>true</debug-mode>
  <max-retries>5</max-retries>
</user-config>
```

### 8. Arrays Containing Objects

When arrays contain objects, each object is wrapped with the array name and index. By default (`strict: false`), object properties within arrays do not include the array item prefix:

```
llml({data: [{name: "Alice", age: 30}, {name: "Bob", age: 25}]})
→
<data>
  <data-1>
    <name>Alice</name>
    <age>30</age>
  </data-1>
  <data-2>
    <name>Bob</name>
    <age>25</age>
  </data-2>
</data>
```

### 9. Complex Mixed Content

Mixed content types are handled by applying the appropriate rule for each type. By default (`strict: false`), nested object properties do not include parent key prefixes:

```
llml({
  title: "My Document",
  sections: ["intro", "body", "conclusion"],
  metadata: {author: "Alice", version: "1.0"}
})
→
<title>My Document</title>
<sections>
  <sections-1>intro</sections-1>
  <sections-2>body</sections-2>
  <sections-3>conclusion</sections-3>
</sections>
<metadata>
  <author>Alice</author>
  <version>1.0</version>
</metadata>
```

### 10. Deep Nesting

Deep nesting follows the same rules recursively. By default (`strict: false`), nested object properties do not include parent key prefixes:

```
llml({level1: {level2: {items: ["a", "b"]}}})
→
<level1>
  <level2>
    <items>
      <items-1>a</items-1>
      <items-2>b</items-2>
    </items>
  </level2>
</level1>
```

### 11. Multiline Content

Multiline strings are formatted with proper indentation, with leading/trailing whitespace trimmed:

```
llml({description: `
    Line 1
    Line 2
    Line 3
    `})
→
<description>
  Line 1
  Line 2
  Line 3
</description>
```

## Configuration Options

### Indentation

Custom indentation can be specified for nested elements:

```
llml({message: "Hello"}, {indent: "  "})
→
  <message>Hello</message>

llml({items: ["a", "b"]}, {indent: "  "})
→
  <items>
    <items-1>a</items-1>
    <items-2>b</items-2>
  </items>
```

**Direct Arrays with Indentation:**
```
llml(["a", "b"], {indent: "  "})
→
  <1>a</1>
  <2>b</2>
```

### Prefix

All generated tags can be prefixed with a namespace:

```
llml({config: "value"}, {prefix: "app"})
→
<app-config>value</app-config>

llml({items: ["a", "b"]}, {prefix: "app"})
→
<app-items>
  <app-items-1>a</app-items-1>
  <app-items-2>b</app-items-2>
</app-items>
```

**Direct Arrays with Prefix:**
```
llml(["a", "b"], {prefix: "item"})
→
<item-1>a</item-1>
<item-2>b</item-2>
```

### Strict Mode

The `strict` option controls whether object keys are used as prefixes in nested fields:

- `strict: false` (default): No object key prefixes in nested fields
- `strict: true`: Object keys are used as prefixes (current behavior)

**Strict Mode Disabled (Default):**
```
llml({config: {debug: true, timeout: 30}}, {strict: false})
→
<config>
  <debug>true</debug>
  <timeout>30</timeout>
</config>

llml({user_config: {debug_mode: true, maxRetries: 5}}, {strict: false})
→
<user-config>
  <debug-mode>true</debug-mode>
  <max-retries>5</max-retries>
</user-config>

llml({data: [{name: "Alice", age: 30}, {name: "Bob", age: 25}]}, {strict: false})
→
<data>
  <data-1>
    <name>Alice</name>
    <age>30</age>
  </data-1>
  <data-2>
    <name>Bob</name>
    <age>25</age>
  </data-2>
</data>
```

**Strict Mode Enabled:**
```
llml({config: {debug: true, timeout: 30}}, {strict: true})
→
<config>
  <config-debug>true</config-debug>
  <config-timeout>30</config-timeout>
</config>

llml({user_config: {debug_mode: true, maxRetries: 5}}, {strict: true})
→
<user-config>
  <user-config-debug-mode>true</user-config-debug-mode>
  <user-config-max-retries>5</user-config-max-retries>
</user-config>

llml({data: [{name: "Alice", age: 30}, {name: "Bob", age: 25}]}, {strict: true})
→
<data>
  <data-1>
    <data-1-name>Alice</data-1-name>
    <data-1-age>30</data-1-age>
  </data-1>
  <data-2>
    <data-2-name>Bob</data-2-name>
    <data-2-age>25</data-2-age>
  </data-2>
</data>
```

## Language-Specific Implementation Details

### Function Signatures

**TypeScript:**
```typescript
function llml(data?: any, options?: {indent?: string, prefix?: string, strict?: boolean}): string
```

**Python:**
```python
def llml(*args, options: Options = None, indent: str = "", prefix: str = "", strict: bool = False, **parts) -> str
```

### Type Representation

**Booleans:**
- TypeScript: `true`/`false` (lowercase)
- Python: `True`/`False` (capitalized)

**Null/None:**
- TypeScript: `null`/`undefined`
- Python: `None`

## Edge Cases and Special Behaviors

### Empty Arrays in Objects
Empty arrays within objects are completely omitted from output:
```
llml({items: []}) → ""
```

### Zero and False Values
Zero and false values are preserved (not treated as empty):
```
llml({count: 0}) → "<count>0</count>"
llml({enabled: false}) → "<enabled>false</enabled>"
```

### Empty Strings
Empty strings are preserved with empty tags:
```
llml({message: ""}) → "<message></message>"
```

### Single Argument vs Multiple Arguments

**Python supports both patterns:**
```python
# Single object argument
llml({name: "Alice", age: 30})

# Keyword arguments
llml(name="Alice", age=30)

# Mixed (single argument takes precedence)
llml({title: "Document"}, name="Alice")  # Only {title: "Document"} is used
```

**TypeScript uses single argument:**
```typescript
llml({name: "Alice", age: 30})
```

## Indentation Rules

- Base indentation is applied to all top-level elements
- Each nesting level adds one more indentation unit
- Array wrapper tags receive the same indentation as their parent
- Array items are indented one level deeper than their wrapper
- Object properties within arrays inherit the array item's indentation level

## Tag Naming Convention

1. Convert all keys to kebab-case
2. For array items, append `-{index}` to the key name (1-indexed)
3. For nested objects:
   - If `strict: false` (default): Use child key name only (no parent key prefix)
   - If `strict: true`: Concatenate parent and child keys with `-`
4. Apply prefix to all generated tag names if specified

## Validation Requirements

Implementations must produce identical output for identical input across all supported languages. Test suites should verify:

1. All primitive type handling
2. Empty value scenarios
3. Kebab-case conversion accuracy
4. Array formatting consistency
5. Nested structure handling
6. Configuration option behavior
7. Multiline content processing
8. Edge cases and error conditions

This specification ensures consistent behavior across Python, TypeScript, Rust, and Go implementations of LLML.
